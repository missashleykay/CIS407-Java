7.10 LAB: Descending selection sort with output during execution

Write a void method selectionSortDescendTrace() that takes an integer array, and sorts the array into descending order. 
The method should use nested loops and output the array after each iteration of the outer loop, thus outputting the array N-1 times 
(where N is the size). Complete the main() to read in a list of up to 10 positive integers (ending in -1) 
and then call the selectionSortDescendTrace() method.

import java.util.Scanner;

public class DescendingOrder {
   public static void selectionSortDescendTrace(int [] numbers, int numElements) {
   int temp,p;
for(int i=0;i<numElements-1;i++)
{
   p=i;
for(int j=i+1;j<numElements;j++)
{
    if(numbers[p]<numbers[j])
    p=j;
}
if(p!=i)
{
temp=numbers[i];
numbers[i]=numbers[p];
numbers[p]=temp;
}
for(int k=0;k<numElements;k++)
System.out.print(numbers[k]+" ");
System.out.println();
}
}


public static void main(String[] args) {
Scanner scnr = new Scanner(System.in);
int input, i = 0;
int numElements = 0;
int [] numbers = new int[10];

input=scnr.nextInt();
while(input!=-1 && numElements<10)
{
   numbers[numElements]=input;
   input=scnr.nextInt();
   numElements++;
}

selectionSortDescendTrace(numbers,numElements);
}
}
**********************************************************************
7.11 LAB: Sorting user IDs

Given a main() that reads user IDs (until -1), complete the quicksort()and partition() methods to sort the IDs in ascending order
using the Quicksort algorithm, and output the sorted IDs one per line.

import java.util.Scanner;
import java.util.ArrayList;

public class UserIDSorting {
   // TODO: Write the partitioning algorithm - pick the middle element as the
   // pivot, compare the values using two index variables l and h (low and high),
   // initialized to the left and right sides of the current elements being sorted,
   // and determine if a swap is necessary
   public static int partition(ArrayList<String> userIDs, int i, int k) {
      
      
       String piv = userIDs.get(k);
       int index = (i - 1);
       for (int j = i; j < k; j++) {

           if (userIDs.get(j).compareTo(piv) <= 0) {
               index++;

               String temp = userIDs.get(index);
               userIDs.set(index, userIDs.get(j));
               userIDs.set(j, temp);
           }
       }

       String temp = userIDs.get(index+1);
       userIDs.set(index+1, userIDs.get(k));
       userIDs.set(k, temp);

       return index + 1;

   }

   // TODO: Write the quicksort algorithm that recursively sorts the low and
   // high partitions
   public static void quicksort(ArrayList<String> userIDs, int i, int k) {
      
       if (i < k) {

           int pi = partition(userIDs, i, k);

           quicksort(userIDs, i, pi - 1);
           quicksort(userIDs, pi + 1, k);
       }

   }

   public static void main(String[] args) {
       Scanner scnr = new Scanner(System.in);

       ArrayList<String> userIDList = new ArrayList<String>();

       String userID;

       userID = scnr.next();
       while (!userID.equals("-1")) {
           userIDList.add(userID);
           userID = scnr.next();
       }

       // Initial call to quicksort
       quicksort(userIDList, 0, userIDList.size() - 1);

       for (int i = 0; i < userIDList.size(); ++i) {
           System.out.println(userIDList.get(i));
       }
   }
}
